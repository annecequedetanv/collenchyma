/* automatically generated by rust-bindgen */

pub type ptrdiff_t = ::libc::c_long;
pub type size_t = ::libc::c_ulong;
pub type wchar_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed1 {
    pub __clang_max_align_nonce1: ::libc::c_longlong,
    pub __clang_max_align_nonce2: ::libc::c_double,
}
impl ::std::clone::Clone for Struct_Unnamed1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type max_align_t = Struct_Unnamed1;
pub type Enum_cudaError = ::libc::c_uint;
pub const cudaSuccess: ::libc::c_uint = 0;
pub const cudaErrorMissingConfiguration: ::libc::c_uint = 1;
pub const cudaErrorMemoryAllocation: ::libc::c_uint = 2;
pub const cudaErrorInitializationError: ::libc::c_uint = 3;
pub const cudaErrorLaunchFailure: ::libc::c_uint = 4;
pub const cudaErrorPriorLaunchFailure: ::libc::c_uint = 5;
pub const cudaErrorLaunchTimeout: ::libc::c_uint = 6;
pub const cudaErrorLaunchOutOfResources: ::libc::c_uint = 7;
pub const cudaErrorInvalidDeviceFunction: ::libc::c_uint = 8;
pub const cudaErrorInvalidConfiguration: ::libc::c_uint = 9;
pub const cudaErrorInvalidDevice: ::libc::c_uint = 10;
pub const cudaErrorInvalidValue: ::libc::c_uint = 11;
pub const cudaErrorInvalidPitchValue: ::libc::c_uint = 12;
pub const cudaErrorInvalidSymbol: ::libc::c_uint = 13;
pub const cudaErrorMapBufferObjectFailed: ::libc::c_uint = 14;
pub const cudaErrorUnmapBufferObjectFailed: ::libc::c_uint = 15;
pub const cudaErrorInvalidHostPointer: ::libc::c_uint = 16;
pub const cudaErrorInvalidDevicePointer: ::libc::c_uint = 17;
pub const cudaErrorInvalidTexture: ::libc::c_uint = 18;
pub const cudaErrorInvalidTextureBinding: ::libc::c_uint = 19;
pub const cudaErrorInvalidChannelDescriptor: ::libc::c_uint = 20;
pub const cudaErrorInvalidMemcpyDirection: ::libc::c_uint = 21;
pub const cudaErrorAddressOfConstant: ::libc::c_uint = 22;
pub const cudaErrorTextureFetchFailed: ::libc::c_uint = 23;
pub const cudaErrorTextureNotBound: ::libc::c_uint = 24;
pub const cudaErrorSynchronizationError: ::libc::c_uint = 25;
pub const cudaErrorInvalidFilterSetting: ::libc::c_uint = 26;
pub const cudaErrorInvalidNormSetting: ::libc::c_uint = 27;
pub const cudaErrorMixedDeviceExecution: ::libc::c_uint = 28;
pub const cudaErrorCudartUnloading: ::libc::c_uint = 29;
pub const cudaErrorUnknown: ::libc::c_uint = 30;
pub const cudaErrorNotYetImplemented: ::libc::c_uint = 31;
pub const cudaErrorMemoryValueTooLarge: ::libc::c_uint = 32;
pub const cudaErrorInvalidResourceHandle: ::libc::c_uint = 33;
pub const cudaErrorNotReady: ::libc::c_uint = 34;
pub const cudaErrorInsufficientDriver: ::libc::c_uint = 35;
pub const cudaErrorSetOnActiveProcess: ::libc::c_uint = 36;
pub const cudaErrorInvalidSurface: ::libc::c_uint = 37;
pub const cudaErrorNoDevice: ::libc::c_uint = 38;
pub const cudaErrorECCUncorrectable: ::libc::c_uint = 39;
pub const cudaErrorSharedObjectSymbolNotFound: ::libc::c_uint = 40;
pub const cudaErrorSharedObjectInitFailed: ::libc::c_uint = 41;
pub const cudaErrorUnsupportedLimit: ::libc::c_uint = 42;
pub const cudaErrorDuplicateVariableName: ::libc::c_uint = 43;
pub const cudaErrorDuplicateTextureName: ::libc::c_uint = 44;
pub const cudaErrorDuplicateSurfaceName: ::libc::c_uint = 45;
pub const cudaErrorDevicesUnavailable: ::libc::c_uint = 46;
pub const cudaErrorInvalidKernelImage: ::libc::c_uint = 47;
pub const cudaErrorNoKernelImageForDevice: ::libc::c_uint = 48;
pub const cudaErrorIncompatibleDriverContext: ::libc::c_uint = 49;
pub const cudaErrorPeerAccessAlreadyEnabled: ::libc::c_uint = 50;
pub const cudaErrorPeerAccessNotEnabled: ::libc::c_uint = 51;
pub const cudaErrorDeviceAlreadyInUse: ::libc::c_uint = 54;
pub const cudaErrorProfilerDisabled: ::libc::c_uint = 55;
pub const cudaErrorProfilerNotInitialized: ::libc::c_uint = 56;
pub const cudaErrorProfilerAlreadyStarted: ::libc::c_uint = 57;
pub const cudaErrorProfilerAlreadyStopped: ::libc::c_uint = 58;
pub const cudaErrorAssert: ::libc::c_uint = 59;
pub const cudaErrorTooManyPeers: ::libc::c_uint = 60;
pub const cudaErrorHostMemoryAlreadyRegistered: ::libc::c_uint = 61;
pub const cudaErrorHostMemoryNotRegistered: ::libc::c_uint = 62;
pub const cudaErrorOperatingSystem: ::libc::c_uint = 63;
pub const cudaErrorPeerAccessUnsupported: ::libc::c_uint = 64;
pub const cudaErrorLaunchMaxDepthExceeded: ::libc::c_uint = 65;
pub const cudaErrorLaunchFileScopedTex: ::libc::c_uint = 66;
pub const cudaErrorLaunchFileScopedSurf: ::libc::c_uint = 67;
pub const cudaErrorSyncDepthExceeded: ::libc::c_uint = 68;
pub const cudaErrorLaunchPendingCountExceeded: ::libc::c_uint = 69;
pub const cudaErrorNotPermitted: ::libc::c_uint = 70;
pub const cudaErrorNotSupported: ::libc::c_uint = 71;
pub const cudaErrorHardwareStackError: ::libc::c_uint = 72;
pub const cudaErrorIllegalInstruction: ::libc::c_uint = 73;
pub const cudaErrorMisalignedAddress: ::libc::c_uint = 74;
pub const cudaErrorInvalidAddressSpace: ::libc::c_uint = 75;
pub const cudaErrorInvalidPc: ::libc::c_uint = 76;
pub const cudaErrorIllegalAddress: ::libc::c_uint = 77;
pub const cudaErrorInvalidPtx: ::libc::c_uint = 78;
pub const cudaErrorInvalidGraphicsContext: ::libc::c_uint = 79;
pub const cudaErrorStartupFailure: ::libc::c_uint = 127;
pub const cudaErrorApiFailureBase: ::libc::c_uint = 10000;
pub type Enum_cudaChannelFormatKind = ::libc::c_uint;
pub const cudaChannelFormatKindSigned: ::libc::c_uint = 0;
pub const cudaChannelFormatKindUnsigned: ::libc::c_uint = 1;
pub const cudaChannelFormatKindFloat: ::libc::c_uint = 2;
pub const cudaChannelFormatKindNone: ::libc::c_uint = 3;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_cudaChannelFormatDesc {
    pub x: ::libc::c_int,
    pub y: ::libc::c_int,
    pub z: ::libc::c_int,
    pub w: ::libc::c_int,
    pub f: Enum_cudaChannelFormatKind,
}
impl ::std::clone::Clone for Struct_cudaChannelFormatDesc {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_cudaChannelFormatDesc {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_cudaArray { }
pub type cudaArray_t = *mut Struct_cudaArray;
pub type cudaArray_const_t = *const Struct_cudaArray;
pub enum Struct_cudaMipmappedArray { }
pub type cudaMipmappedArray_t = *mut Struct_cudaMipmappedArray;
pub type cudaMipmappedArray_const_t = *const Struct_cudaMipmappedArray;
pub type Enum_cudaMemoryType = ::libc::c_uint;
pub const cudaMemoryTypeHost: ::libc::c_uint = 1;
pub const cudaMemoryTypeDevice: ::libc::c_uint = 2;
pub type Enum_cudaMemcpyKind = ::libc::c_uint;
pub const cudaMemcpyHostToHost: ::libc::c_uint = 0;
pub const cudaMemcpyHostToDevice: ::libc::c_uint = 1;
pub const cudaMemcpyDeviceToHost: ::libc::c_uint = 2;
pub const cudaMemcpyDeviceToDevice: ::libc::c_uint = 3;
pub const cudaMemcpyDefault: ::libc::c_uint = 4;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_cudaPitchedPtr {
    pub ptr: *mut ::libc::c_void,
    pub pitch: size_t,
    pub xsize: size_t,
    pub ysize: size_t,
}
impl ::std::clone::Clone for Struct_cudaPitchedPtr {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_cudaPitchedPtr {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_cudaExtent {
    pub width: size_t,
    pub height: size_t,
    pub depth: size_t,
}
impl ::std::clone::Clone for Struct_cudaExtent {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_cudaExtent {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_cudaPos {
    pub x: size_t,
    pub y: size_t,
    pub z: size_t,
}
impl ::std::clone::Clone for Struct_cudaPos {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_cudaPos {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_cudaMemcpy3DParms {
    pub srcArray: cudaArray_t,
    pub srcPos: Struct_cudaPos,
    pub srcPtr: Struct_cudaPitchedPtr,
    pub dstArray: cudaArray_t,
    pub dstPos: Struct_cudaPos,
    pub dstPtr: Struct_cudaPitchedPtr,
    pub extent: Struct_cudaExtent,
    pub kind: Enum_cudaMemcpyKind,
}
impl ::std::clone::Clone for Struct_cudaMemcpy3DParms {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_cudaMemcpy3DParms {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_cudaMemcpy3DPeerParms {
    pub srcArray: cudaArray_t,
    pub srcPos: Struct_cudaPos,
    pub srcPtr: Struct_cudaPitchedPtr,
    pub srcDevice: ::libc::c_int,
    pub dstArray: cudaArray_t,
    pub dstPos: Struct_cudaPos,
    pub dstPtr: Struct_cudaPitchedPtr,
    pub dstDevice: ::libc::c_int,
    pub extent: Struct_cudaExtent,
}
impl ::std::clone::Clone for Struct_cudaMemcpy3DPeerParms {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_cudaMemcpy3DPeerParms {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub enum Struct_cudaGraphicsResource { }
pub type Enum_cudaGraphicsRegisterFlags = ::libc::c_uint;
pub const cudaGraphicsRegisterFlagsNone: ::libc::c_uint = 0;
pub const cudaGraphicsRegisterFlagsReadOnly: ::libc::c_uint = 1;
pub const cudaGraphicsRegisterFlagsWriteDiscard: ::libc::c_uint = 2;
pub const cudaGraphicsRegisterFlagsSurfaceLoadStore: ::libc::c_uint = 4;
pub const cudaGraphicsRegisterFlagsTextureGather: ::libc::c_uint = 8;
pub type Enum_cudaGraphicsMapFlags = ::libc::c_uint;
pub const cudaGraphicsMapFlagsNone: ::libc::c_uint = 0;
pub const cudaGraphicsMapFlagsReadOnly: ::libc::c_uint = 1;
pub const cudaGraphicsMapFlagsWriteDiscard: ::libc::c_uint = 2;
pub type Enum_cudaGraphicsCubeFace = ::libc::c_uint;
pub const cudaGraphicsCubeFacePositiveX: ::libc::c_uint = 0;
pub const cudaGraphicsCubeFaceNegativeX: ::libc::c_uint = 1;
pub const cudaGraphicsCubeFacePositiveY: ::libc::c_uint = 2;
pub const cudaGraphicsCubeFaceNegativeY: ::libc::c_uint = 3;
pub const cudaGraphicsCubeFacePositiveZ: ::libc::c_uint = 4;
pub const cudaGraphicsCubeFaceNegativeZ: ::libc::c_uint = 5;
pub type Enum_cudaResourceType = ::libc::c_uint;
pub const cudaResourceTypeArray: ::libc::c_uint = 0;
pub const cudaResourceTypeMipmappedArray: ::libc::c_uint = 1;
pub const cudaResourceTypeLinear: ::libc::c_uint = 2;
pub const cudaResourceTypePitch2D: ::libc::c_uint = 3;
pub type Enum_cudaResourceViewFormat = ::libc::c_uint;
pub const cudaResViewFormatNone: ::libc::c_uint = 0;
pub const cudaResViewFormatUnsignedChar1: ::libc::c_uint = 1;
pub const cudaResViewFormatUnsignedChar2: ::libc::c_uint = 2;
pub const cudaResViewFormatUnsignedChar4: ::libc::c_uint = 3;
pub const cudaResViewFormatSignedChar1: ::libc::c_uint = 4;
pub const cudaResViewFormatSignedChar2: ::libc::c_uint = 5;
pub const cudaResViewFormatSignedChar4: ::libc::c_uint = 6;
pub const cudaResViewFormatUnsignedShort1: ::libc::c_uint = 7;
pub const cudaResViewFormatUnsignedShort2: ::libc::c_uint = 8;
pub const cudaResViewFormatUnsignedShort4: ::libc::c_uint = 9;
pub const cudaResViewFormatSignedShort1: ::libc::c_uint = 10;
pub const cudaResViewFormatSignedShort2: ::libc::c_uint = 11;
pub const cudaResViewFormatSignedShort4: ::libc::c_uint = 12;
pub const cudaResViewFormatUnsignedInt1: ::libc::c_uint = 13;
pub const cudaResViewFormatUnsignedInt2: ::libc::c_uint = 14;
pub const cudaResViewFormatUnsignedInt4: ::libc::c_uint = 15;
pub const cudaResViewFormatSignedInt1: ::libc::c_uint = 16;
pub const cudaResViewFormatSignedInt2: ::libc::c_uint = 17;
pub const cudaResViewFormatSignedInt4: ::libc::c_uint = 18;
pub const cudaResViewFormatHalf1: ::libc::c_uint = 19;
pub const cudaResViewFormatHalf2: ::libc::c_uint = 20;
pub const cudaResViewFormatHalf4: ::libc::c_uint = 21;
pub const cudaResViewFormatFloat1: ::libc::c_uint = 22;
pub const cudaResViewFormatFloat2: ::libc::c_uint = 23;
pub const cudaResViewFormatFloat4: ::libc::c_uint = 24;
pub const cudaResViewFormatUnsignedBlockCompressed1: ::libc::c_uint = 25;
pub const cudaResViewFormatUnsignedBlockCompressed2: ::libc::c_uint = 26;
pub const cudaResViewFormatUnsignedBlockCompressed3: ::libc::c_uint = 27;
pub const cudaResViewFormatUnsignedBlockCompressed4: ::libc::c_uint = 28;
pub const cudaResViewFormatSignedBlockCompressed4: ::libc::c_uint = 29;
pub const cudaResViewFormatUnsignedBlockCompressed5: ::libc::c_uint = 30;
pub const cudaResViewFormatSignedBlockCompressed5: ::libc::c_uint = 31;
pub const cudaResViewFormatUnsignedBlockCompressed6H: ::libc::c_uint = 32;
pub const cudaResViewFormatSignedBlockCompressed6H: ::libc::c_uint = 33;
pub const cudaResViewFormatUnsignedBlockCompressed7: ::libc::c_uint = 34;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_cudaResourceDesc {
    pub resType: Enum_cudaResourceType,
    pub res: Union_Unnamed2,
}
impl ::std::clone::Clone for Struct_cudaResourceDesc {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_cudaResourceDesc {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Union_Unnamed2 {
    pub _bindgen_data_: [u64; 7usize],
}
impl Union_Unnamed2 {
    pub unsafe fn array(&mut self) -> *mut Struct_Unnamed3 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn mipmap(&mut self) -> *mut Struct_Unnamed4 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn linear(&mut self) -> *mut Struct_Unnamed5 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
    pub unsafe fn pitch2D(&mut self) -> *mut Struct_Unnamed6 {
        let raw: *mut u8 = ::std::mem::transmute(&self._bindgen_data_);
        ::std::mem::transmute(raw.offset(0))
    }
}
impl ::std::clone::Clone for Union_Unnamed2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Union_Unnamed2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed3 {
    pub array: cudaArray_t,
}
impl ::std::clone::Clone for Struct_Unnamed3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed4 {
    pub mipmap: cudaMipmappedArray_t,
}
impl ::std::clone::Clone for Struct_Unnamed4 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed5 {
    pub devPtr: *mut ::libc::c_void,
    pub desc: Struct_cudaChannelFormatDesc,
    pub sizeInBytes: size_t,
}
impl ::std::clone::Clone for Struct_Unnamed5 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed5 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed6 {
    pub devPtr: *mut ::libc::c_void,
    pub desc: Struct_cudaChannelFormatDesc,
    pub width: size_t,
    pub height: size_t,
    pub pitchInBytes: size_t,
}
impl ::std::clone::Clone for Struct_Unnamed6 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed6 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_cudaResourceViewDesc {
    pub format: Enum_cudaResourceViewFormat,
    pub width: size_t,
    pub height: size_t,
    pub depth: size_t,
    pub firstMipmapLevel: ::libc::c_uint,
    pub lastMipmapLevel: ::libc::c_uint,
    pub firstLayer: ::libc::c_uint,
    pub lastLayer: ::libc::c_uint,
}
impl ::std::clone::Clone for Struct_cudaResourceViewDesc {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_cudaResourceViewDesc {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_cudaPointerAttributes {
    pub memoryType: Enum_cudaMemoryType,
    pub device: ::libc::c_int,
    pub devicePointer: *mut ::libc::c_void,
    pub hostPointer: *mut ::libc::c_void,
    pub isManaged: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_cudaPointerAttributes {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_cudaPointerAttributes {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_cudaFuncAttributes {
    pub sharedSizeBytes: size_t,
    pub constSizeBytes: size_t,
    pub localSizeBytes: size_t,
    pub maxThreadsPerBlock: ::libc::c_int,
    pub numRegs: ::libc::c_int,
    pub ptxVersion: ::libc::c_int,
    pub binaryVersion: ::libc::c_int,
    pub cacheModeCA: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_cudaFuncAttributes {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_cudaFuncAttributes {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type Enum_cudaFuncCache = ::libc::c_uint;
pub const cudaFuncCachePreferNone: ::libc::c_uint = 0;
pub const cudaFuncCachePreferShared: ::libc::c_uint = 1;
pub const cudaFuncCachePreferL1: ::libc::c_uint = 2;
pub const cudaFuncCachePreferEqual: ::libc::c_uint = 3;
pub type Enum_cudaSharedMemConfig = ::libc::c_uint;
pub const cudaSharedMemBankSizeDefault: ::libc::c_uint = 0;
pub const cudaSharedMemBankSizeFourByte: ::libc::c_uint = 1;
pub const cudaSharedMemBankSizeEightByte: ::libc::c_uint = 2;
pub type Enum_cudaComputeMode = ::libc::c_uint;
pub const cudaComputeModeDefault: ::libc::c_uint = 0;
pub const cudaComputeModeExclusive: ::libc::c_uint = 1;
pub const cudaComputeModeProhibited: ::libc::c_uint = 2;
pub const cudaComputeModeExclusiveProcess: ::libc::c_uint = 3;
pub type Enum_cudaLimit = ::libc::c_uint;
pub const cudaLimitStackSize: ::libc::c_uint = 0;
pub const cudaLimitPrintfFifoSize: ::libc::c_uint = 1;
pub const cudaLimitMallocHeapSize: ::libc::c_uint = 2;
pub const cudaLimitDevRuntimeSyncDepth: ::libc::c_uint = 3;
pub const cudaLimitDevRuntimePendingLaunchCount: ::libc::c_uint = 4;
pub type Enum_cudaOutputMode = ::libc::c_uint;
pub const cudaKeyValuePair: ::libc::c_uint = 0;
pub const cudaCSV: ::libc::c_uint = 1;
pub type Enum_cudaDeviceAttr = ::libc::c_uint;
pub const cudaDevAttrMaxThreadsPerBlock: ::libc::c_uint = 1;
pub const cudaDevAttrMaxBlockDimX: ::libc::c_uint = 2;
pub const cudaDevAttrMaxBlockDimY: ::libc::c_uint = 3;
pub const cudaDevAttrMaxBlockDimZ: ::libc::c_uint = 4;
pub const cudaDevAttrMaxGridDimX: ::libc::c_uint = 5;
pub const cudaDevAttrMaxGridDimY: ::libc::c_uint = 6;
pub const cudaDevAttrMaxGridDimZ: ::libc::c_uint = 7;
pub const cudaDevAttrMaxSharedMemoryPerBlock: ::libc::c_uint = 8;
pub const cudaDevAttrTotalConstantMemory: ::libc::c_uint = 9;
pub const cudaDevAttrWarpSize: ::libc::c_uint = 10;
pub const cudaDevAttrMaxPitch: ::libc::c_uint = 11;
pub const cudaDevAttrMaxRegistersPerBlock: ::libc::c_uint = 12;
pub const cudaDevAttrClockRate: ::libc::c_uint = 13;
pub const cudaDevAttrTextureAlignment: ::libc::c_uint = 14;
pub const cudaDevAttrGpuOverlap: ::libc::c_uint = 15;
pub const cudaDevAttrMultiProcessorCount: ::libc::c_uint = 16;
pub const cudaDevAttrKernelExecTimeout: ::libc::c_uint = 17;
pub const cudaDevAttrIntegrated: ::libc::c_uint = 18;
pub const cudaDevAttrCanMapHostMemory: ::libc::c_uint = 19;
pub const cudaDevAttrComputeMode: ::libc::c_uint = 20;
pub const cudaDevAttrMaxTexture1DWidth: ::libc::c_uint = 21;
pub const cudaDevAttrMaxTexture2DWidth: ::libc::c_uint = 22;
pub const cudaDevAttrMaxTexture2DHeight: ::libc::c_uint = 23;
pub const cudaDevAttrMaxTexture3DWidth: ::libc::c_uint = 24;
pub const cudaDevAttrMaxTexture3DHeight: ::libc::c_uint = 25;
pub const cudaDevAttrMaxTexture3DDepth: ::libc::c_uint = 26;
pub const cudaDevAttrMaxTexture2DLayeredWidth: ::libc::c_uint = 27;
pub const cudaDevAttrMaxTexture2DLayeredHeight: ::libc::c_uint = 28;
pub const cudaDevAttrMaxTexture2DLayeredLayers: ::libc::c_uint = 29;
pub const cudaDevAttrSurfaceAlignment: ::libc::c_uint = 30;
pub const cudaDevAttrConcurrentKernels: ::libc::c_uint = 31;
pub const cudaDevAttrEccEnabled: ::libc::c_uint = 32;
pub const cudaDevAttrPciBusId: ::libc::c_uint = 33;
pub const cudaDevAttrPciDeviceId: ::libc::c_uint = 34;
pub const cudaDevAttrTccDriver: ::libc::c_uint = 35;
pub const cudaDevAttrMemoryClockRate: ::libc::c_uint = 36;
pub const cudaDevAttrGlobalMemoryBusWidth: ::libc::c_uint = 37;
pub const cudaDevAttrL2CacheSize: ::libc::c_uint = 38;
pub const cudaDevAttrMaxThreadsPerMultiProcessor: ::libc::c_uint = 39;
pub const cudaDevAttrAsyncEngineCount: ::libc::c_uint = 40;
pub const cudaDevAttrUnifiedAddressing: ::libc::c_uint = 41;
pub const cudaDevAttrMaxTexture1DLayeredWidth: ::libc::c_uint = 42;
pub const cudaDevAttrMaxTexture1DLayeredLayers: ::libc::c_uint = 43;
pub const cudaDevAttrMaxTexture2DGatherWidth: ::libc::c_uint = 45;
pub const cudaDevAttrMaxTexture2DGatherHeight: ::libc::c_uint = 46;
pub const cudaDevAttrMaxTexture3DWidthAlt: ::libc::c_uint = 47;
pub const cudaDevAttrMaxTexture3DHeightAlt: ::libc::c_uint = 48;
pub const cudaDevAttrMaxTexture3DDepthAlt: ::libc::c_uint = 49;
pub const cudaDevAttrPciDomainId: ::libc::c_uint = 50;
pub const cudaDevAttrTexturePitchAlignment: ::libc::c_uint = 51;
pub const cudaDevAttrMaxTextureCubemapWidth: ::libc::c_uint = 52;
pub const cudaDevAttrMaxTextureCubemapLayeredWidth: ::libc::c_uint = 53;
pub const cudaDevAttrMaxTextureCubemapLayeredLayers: ::libc::c_uint = 54;
pub const cudaDevAttrMaxSurface1DWidth: ::libc::c_uint = 55;
pub const cudaDevAttrMaxSurface2DWidth: ::libc::c_uint = 56;
pub const cudaDevAttrMaxSurface2DHeight: ::libc::c_uint = 57;
pub const cudaDevAttrMaxSurface3DWidth: ::libc::c_uint = 58;
pub const cudaDevAttrMaxSurface3DHeight: ::libc::c_uint = 59;
pub const cudaDevAttrMaxSurface3DDepth: ::libc::c_uint = 60;
pub const cudaDevAttrMaxSurface1DLayeredWidth: ::libc::c_uint = 61;
pub const cudaDevAttrMaxSurface1DLayeredLayers: ::libc::c_uint = 62;
pub const cudaDevAttrMaxSurface2DLayeredWidth: ::libc::c_uint = 63;
pub const cudaDevAttrMaxSurface2DLayeredHeight: ::libc::c_uint = 64;
pub const cudaDevAttrMaxSurface2DLayeredLayers: ::libc::c_uint = 65;
pub const cudaDevAttrMaxSurfaceCubemapWidth: ::libc::c_uint = 66;
pub const cudaDevAttrMaxSurfaceCubemapLayeredWidth: ::libc::c_uint = 67;
pub const cudaDevAttrMaxSurfaceCubemapLayeredLayers: ::libc::c_uint = 68;
pub const cudaDevAttrMaxTexture1DLinearWidth: ::libc::c_uint = 69;
pub const cudaDevAttrMaxTexture2DLinearWidth: ::libc::c_uint = 70;
pub const cudaDevAttrMaxTexture2DLinearHeight: ::libc::c_uint = 71;
pub const cudaDevAttrMaxTexture2DLinearPitch: ::libc::c_uint = 72;
pub const cudaDevAttrMaxTexture2DMipmappedWidth: ::libc::c_uint = 73;
pub const cudaDevAttrMaxTexture2DMipmappedHeight: ::libc::c_uint = 74;
pub const cudaDevAttrComputeCapabilityMajor: ::libc::c_uint = 75;
pub const cudaDevAttrComputeCapabilityMinor: ::libc::c_uint = 76;
pub const cudaDevAttrMaxTexture1DMipmappedWidth: ::libc::c_uint = 77;
pub const cudaDevAttrStreamPrioritiesSupported: ::libc::c_uint = 78;
pub const cudaDevAttrGlobalL1CacheSupported: ::libc::c_uint = 79;
pub const cudaDevAttrLocalL1CacheSupported: ::libc::c_uint = 80;
pub const cudaDevAttrMaxSharedMemoryPerMultiprocessor: ::libc::c_uint = 81;
pub const cudaDevAttrMaxRegistersPerMultiprocessor: ::libc::c_uint = 82;
pub const cudaDevAttrManagedMemory: ::libc::c_uint = 83;
pub const cudaDevAttrIsMultiGpuBoard: ::libc::c_uint = 84;
pub const cudaDevAttrMultiGpuBoardGroupID: ::libc::c_uint = 85;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_cudaDeviceProp {
    pub name: [::libc::c_char; 256usize],
    pub totalGlobalMem: size_t,
    pub sharedMemPerBlock: size_t,
    pub regsPerBlock: ::libc::c_int,
    pub warpSize: ::libc::c_int,
    pub memPitch: size_t,
    pub maxThreadsPerBlock: ::libc::c_int,
    pub maxThreadsDim: [::libc::c_int; 3usize],
    pub maxGridSize: [::libc::c_int; 3usize],
    pub clockRate: ::libc::c_int,
    pub totalConstMem: size_t,
    pub major: ::libc::c_int,
    pub minor: ::libc::c_int,
    pub textureAlignment: size_t,
    pub texturePitchAlignment: size_t,
    pub deviceOverlap: ::libc::c_int,
    pub multiProcessorCount: ::libc::c_int,
    pub kernelExecTimeoutEnabled: ::libc::c_int,
    pub integrated: ::libc::c_int,
    pub canMapHostMemory: ::libc::c_int,
    pub computeMode: ::libc::c_int,
    pub maxTexture1D: ::libc::c_int,
    pub maxTexture1DMipmap: ::libc::c_int,
    pub maxTexture1DLinear: ::libc::c_int,
    pub maxTexture2D: [::libc::c_int; 2usize],
    pub maxTexture2DMipmap: [::libc::c_int; 2usize],
    pub maxTexture2DLinear: [::libc::c_int; 3usize],
    pub maxTexture2DGather: [::libc::c_int; 2usize],
    pub maxTexture3D: [::libc::c_int; 3usize],
    pub maxTexture3DAlt: [::libc::c_int; 3usize],
    pub maxTextureCubemap: ::libc::c_int,
    pub maxTexture1DLayered: [::libc::c_int; 2usize],
    pub maxTexture2DLayered: [::libc::c_int; 3usize],
    pub maxTextureCubemapLayered: [::libc::c_int; 2usize],
    pub maxSurface1D: ::libc::c_int,
    pub maxSurface2D: [::libc::c_int; 2usize],
    pub maxSurface3D: [::libc::c_int; 3usize],
    pub maxSurface1DLayered: [::libc::c_int; 2usize],
    pub maxSurface2DLayered: [::libc::c_int; 3usize],
    pub maxSurfaceCubemap: ::libc::c_int,
    pub maxSurfaceCubemapLayered: [::libc::c_int; 2usize],
    pub surfaceAlignment: size_t,
    pub concurrentKernels: ::libc::c_int,
    pub ECCEnabled: ::libc::c_int,
    pub pciBusID: ::libc::c_int,
    pub pciDeviceID: ::libc::c_int,
    pub pciDomainID: ::libc::c_int,
    pub tccDriver: ::libc::c_int,
    pub asyncEngineCount: ::libc::c_int,
    pub unifiedAddressing: ::libc::c_int,
    pub memoryClockRate: ::libc::c_int,
    pub memoryBusWidth: ::libc::c_int,
    pub l2CacheSize: ::libc::c_int,
    pub maxThreadsPerMultiProcessor: ::libc::c_int,
    pub streamPrioritiesSupported: ::libc::c_int,
    pub globalL1CacheSupported: ::libc::c_int,
    pub localL1CacheSupported: ::libc::c_int,
    pub sharedMemPerMultiprocessor: size_t,
    pub regsPerMultiprocessor: ::libc::c_int,
    pub managedMemory: ::libc::c_int,
    pub isMultiGpuBoard: ::libc::c_int,
    pub multiGpuBoardGroupID: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_cudaDeviceProp {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_cudaDeviceProp {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_cudaIpcEventHandle_st {
    pub reserved: [::libc::c_char; 64usize],
}
impl ::std::clone::Clone for Struct_cudaIpcEventHandle_st {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_cudaIpcEventHandle_st {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type cudaIpcEventHandle_t = Struct_cudaIpcEventHandle_st;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_cudaIpcMemHandle_st {
    pub reserved: [::libc::c_char; 64usize],
}
impl ::std::clone::Clone for Struct_cudaIpcMemHandle_st {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_cudaIpcMemHandle_st {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type cudaIpcMemHandle_t = Struct_cudaIpcMemHandle_st;
pub type cudaError_t = Enum_cudaError;
pub enum Struct_CUstream_st { }
pub type cudaStream_t = *mut Struct_CUstream_st;
pub enum Struct_CUevent_st { }
pub type cudaEvent_t = *mut Struct_CUevent_st;
pub type cudaGraphicsResource_t = *mut Struct_cudaGraphicsResource;
pub enum Struct_CUuuid_st { }
pub type cudaUUID_t = Struct_CUuuid_st;
pub type cudaOutputMode_t = Enum_cudaOutputMode;
pub type Enum_cudaRoundMode = ::libc::c_uint;
pub const cudaRoundNearest: ::libc::c_uint = 0;
pub const cudaRoundZero: ::libc::c_uint = 1;
pub const cudaRoundPosInf: ::libc::c_uint = 2;
pub const cudaRoundMinInf: ::libc::c_uint = 3;
pub type Enum_cudaSurfaceBoundaryMode = ::libc::c_uint;
pub const cudaBoundaryModeZero: ::libc::c_uint = 0;
pub const cudaBoundaryModeClamp: ::libc::c_uint = 1;
pub const cudaBoundaryModeTrap: ::libc::c_uint = 2;
pub type Enum_cudaSurfaceFormatMode = ::libc::c_uint;
pub const cudaFormatModeForced: ::libc::c_uint = 0;
pub const cudaFormatModeAuto: ::libc::c_uint = 1;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_surfaceReference {
    pub channelDesc: Struct_cudaChannelFormatDesc,
}
impl ::std::clone::Clone for Struct_surfaceReference {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_surfaceReference {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type cudaSurfaceObject_t = ::libc::c_ulonglong;
pub type Enum_cudaTextureAddressMode = ::libc::c_uint;
pub const cudaAddressModeWrap: ::libc::c_uint = 0;
pub const cudaAddressModeClamp: ::libc::c_uint = 1;
pub const cudaAddressModeMirror: ::libc::c_uint = 2;
pub const cudaAddressModeBorder: ::libc::c_uint = 3;
pub type Enum_cudaTextureFilterMode = ::libc::c_uint;
pub const cudaFilterModePoint: ::libc::c_uint = 0;
pub const cudaFilterModeLinear: ::libc::c_uint = 1;
pub type Enum_cudaTextureReadMode = ::libc::c_uint;
pub const cudaReadModeElementType: ::libc::c_uint = 0;
pub const cudaReadModeNormalizedFloat: ::libc::c_uint = 1;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_textureReference {
    pub normalized: ::libc::c_int,
    pub filterMode: Enum_cudaTextureFilterMode,
    pub addressMode: [Enum_cudaTextureAddressMode; 3usize],
    pub channelDesc: Struct_cudaChannelFormatDesc,
    pub sRGB: ::libc::c_int,
    pub maxAnisotropy: ::libc::c_uint,
    pub mipmapFilterMode: Enum_cudaTextureFilterMode,
    pub mipmapLevelBias: ::libc::c_float,
    pub minMipmapLevelClamp: ::libc::c_float,
    pub maxMipmapLevelClamp: ::libc::c_float,
    pub __cudaReserved: [::libc::c_int; 15usize],
}
impl ::std::clone::Clone for Struct_textureReference {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_textureReference {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_cudaTextureDesc {
    pub addressMode: [Enum_cudaTextureAddressMode; 3usize],
    pub filterMode: Enum_cudaTextureFilterMode,
    pub readMode: Enum_cudaTextureReadMode,
    pub sRGB: ::libc::c_int,
    pub normalizedCoords: ::libc::c_int,
    pub maxAnisotropy: ::libc::c_uint,
    pub mipmapFilterMode: Enum_cudaTextureFilterMode,
    pub mipmapLevelBias: ::libc::c_float,
    pub minMipmapLevelClamp: ::libc::c_float,
    pub maxMipmapLevelClamp: ::libc::c_float,
}
impl ::std::clone::Clone for Struct_cudaTextureDesc {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_cudaTextureDesc {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type cudaTextureObject_t = ::libc::c_ulonglong;
#[repr(C)]
#[derive(Copy)]
pub struct Struct_char1 {
    pub x: ::libc::c_char,
}
impl ::std::clone::Clone for Struct_char1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_char1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_uchar1 {
    pub x: ::libc::c_uchar,
}
impl ::std::clone::Clone for Struct_uchar1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_uchar1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_char2 {
    pub x: ::libc::c_char,
    pub y: ::libc::c_char,
}
impl ::std::clone::Clone for Struct_char2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_char2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_uchar2 {
    pub x: ::libc::c_uchar,
    pub y: ::libc::c_uchar,
}
impl ::std::clone::Clone for Struct_uchar2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_uchar2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_char3 {
    pub x: ::libc::c_char,
    pub y: ::libc::c_char,
    pub z: ::libc::c_char,
}
impl ::std::clone::Clone for Struct_char3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_char3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_uchar3 {
    pub x: ::libc::c_uchar,
    pub y: ::libc::c_uchar,
    pub z: ::libc::c_uchar,
}
impl ::std::clone::Clone for Struct_uchar3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_uchar3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_char4 {
    pub x: ::libc::c_char,
    pub y: ::libc::c_char,
    pub z: ::libc::c_char,
    pub w: ::libc::c_char,
}
impl ::std::clone::Clone for Struct_char4 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_char4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_uchar4 {
    pub x: ::libc::c_uchar,
    pub y: ::libc::c_uchar,
    pub z: ::libc::c_uchar,
    pub w: ::libc::c_uchar,
}
impl ::std::clone::Clone for Struct_uchar4 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_uchar4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_short1 {
    pub x: ::libc::c_short,
}
impl ::std::clone::Clone for Struct_short1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_short1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ushort1 {
    pub x: ::libc::c_ushort,
}
impl ::std::clone::Clone for Struct_ushort1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ushort1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_short2 {
    pub x: ::libc::c_short,
    pub y: ::libc::c_short,
}
impl ::std::clone::Clone for Struct_short2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_short2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ushort2 {
    pub x: ::libc::c_ushort,
    pub y: ::libc::c_ushort,
}
impl ::std::clone::Clone for Struct_ushort2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ushort2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_short3 {
    pub x: ::libc::c_short,
    pub y: ::libc::c_short,
    pub z: ::libc::c_short,
}
impl ::std::clone::Clone for Struct_short3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_short3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ushort3 {
    pub x: ::libc::c_ushort,
    pub y: ::libc::c_ushort,
    pub z: ::libc::c_ushort,
}
impl ::std::clone::Clone for Struct_ushort3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ushort3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_short4 {
    pub x: ::libc::c_short,
    pub y: ::libc::c_short,
    pub z: ::libc::c_short,
    pub w: ::libc::c_short,
}
impl ::std::clone::Clone for Struct_short4 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_short4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ushort4 {
    pub x: ::libc::c_ushort,
    pub y: ::libc::c_ushort,
    pub z: ::libc::c_ushort,
    pub w: ::libc::c_ushort,
}
impl ::std::clone::Clone for Struct_ushort4 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ushort4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_int1 {
    pub x: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_int1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_int1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_uint1 {
    pub x: ::libc::c_uint,
}
impl ::std::clone::Clone for Struct_uint1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_uint1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_int2 {
    pub x: ::libc::c_int,
    pub y: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_int2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_int2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_uint2 {
    pub x: ::libc::c_uint,
    pub y: ::libc::c_uint,
}
impl ::std::clone::Clone for Struct_uint2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_uint2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_int3 {
    pub x: ::libc::c_int,
    pub y: ::libc::c_int,
    pub z: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_int3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_int3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_uint3 {
    pub x: ::libc::c_uint,
    pub y: ::libc::c_uint,
    pub z: ::libc::c_uint,
}
impl ::std::clone::Clone for Struct_uint3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_uint3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_int4 {
    pub x: ::libc::c_int,
    pub y: ::libc::c_int,
    pub z: ::libc::c_int,
    pub w: ::libc::c_int,
}
impl ::std::clone::Clone for Struct_int4 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_int4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_uint4 {
    pub x: ::libc::c_uint,
    pub y: ::libc::c_uint,
    pub z: ::libc::c_uint,
    pub w: ::libc::c_uint,
}
impl ::std::clone::Clone for Struct_uint4 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_uint4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_long1 {
    pub x: ::libc::c_long,
}
impl ::std::clone::Clone for Struct_long1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_long1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ulong1 {
    pub x: ::libc::c_ulong,
}
impl ::std::clone::Clone for Struct_ulong1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ulong1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_long2 {
    pub x: ::libc::c_long,
    pub y: ::libc::c_long,
}
impl ::std::clone::Clone for Struct_long2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_long2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ulong2 {
    pub x: ::libc::c_ulong,
    pub y: ::libc::c_ulong,
}
impl ::std::clone::Clone for Struct_ulong2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ulong2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_long3 {
    pub x: ::libc::c_long,
    pub y: ::libc::c_long,
    pub z: ::libc::c_long,
}
impl ::std::clone::Clone for Struct_long3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_long3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ulong3 {
    pub x: ::libc::c_ulong,
    pub y: ::libc::c_ulong,
    pub z: ::libc::c_ulong,
}
impl ::std::clone::Clone for Struct_ulong3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ulong3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_long4 {
    pub x: ::libc::c_long,
    pub y: ::libc::c_long,
    pub z: ::libc::c_long,
    pub w: ::libc::c_long,
}
impl ::std::clone::Clone for Struct_long4 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_long4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ulong4 {
    pub x: ::libc::c_ulong,
    pub y: ::libc::c_ulong,
    pub z: ::libc::c_ulong,
    pub w: ::libc::c_ulong,
}
impl ::std::clone::Clone for Struct_ulong4 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ulong4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_float1 {
    pub x: ::libc::c_float,
}
impl ::std::clone::Clone for Struct_float1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_float1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_float2 {
    pub x: ::libc::c_float,
    pub y: ::libc::c_float,
}
impl ::std::clone::Clone for Struct_float2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_float2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_float3 {
    pub x: ::libc::c_float,
    pub y: ::libc::c_float,
    pub z: ::libc::c_float,
}
impl ::std::clone::Clone for Struct_float3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_float3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_float4 {
    pub x: ::libc::c_float,
    pub y: ::libc::c_float,
    pub z: ::libc::c_float,
    pub w: ::libc::c_float,
}
impl ::std::clone::Clone for Struct_float4 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_float4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_longlong1 {
    pub x: ::libc::c_longlong,
}
impl ::std::clone::Clone for Struct_longlong1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_longlong1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ulonglong1 {
    pub x: ::libc::c_ulonglong,
}
impl ::std::clone::Clone for Struct_ulonglong1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ulonglong1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_longlong2 {
    pub x: ::libc::c_longlong,
    pub y: ::libc::c_longlong,
}
impl ::std::clone::Clone for Struct_longlong2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_longlong2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ulonglong2 {
    pub x: ::libc::c_ulonglong,
    pub y: ::libc::c_ulonglong,
}
impl ::std::clone::Clone for Struct_ulonglong2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ulonglong2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_longlong3 {
    pub x: ::libc::c_longlong,
    pub y: ::libc::c_longlong,
    pub z: ::libc::c_longlong,
}
impl ::std::clone::Clone for Struct_longlong3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_longlong3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ulonglong3 {
    pub x: ::libc::c_ulonglong,
    pub y: ::libc::c_ulonglong,
    pub z: ::libc::c_ulonglong,
}
impl ::std::clone::Clone for Struct_ulonglong3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ulonglong3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_longlong4 {
    pub x: ::libc::c_longlong,
    pub y: ::libc::c_longlong,
    pub z: ::libc::c_longlong,
    pub w: ::libc::c_longlong,
}
impl ::std::clone::Clone for Struct_longlong4 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_longlong4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_ulonglong4 {
    pub x: ::libc::c_ulonglong,
    pub y: ::libc::c_ulonglong,
    pub z: ::libc::c_ulonglong,
    pub w: ::libc::c_ulonglong,
}
impl ::std::clone::Clone for Struct_ulonglong4 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_ulonglong4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_double1 {
    pub x: ::libc::c_double,
}
impl ::std::clone::Clone for Struct_double1 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_double1 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_double2 {
    pub x: ::libc::c_double,
    pub y: ::libc::c_double,
}
impl ::std::clone::Clone for Struct_double2 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_double2 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_double3 {
    pub x: ::libc::c_double,
    pub y: ::libc::c_double,
    pub z: ::libc::c_double,
}
impl ::std::clone::Clone for Struct_double3 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_double3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
#[repr(C)]
#[derive(Copy)]
pub struct Struct_double4 {
    pub x: ::libc::c_double,
    pub y: ::libc::c_double,
    pub z: ::libc::c_double,
    pub w: ::libc::c_double,
}
impl ::std::clone::Clone for Struct_double4 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_double4 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type char1 = Struct_char1;
pub type uchar1 = Struct_uchar1;
pub type char2 = Struct_char2;
pub type uchar2 = Struct_uchar2;
pub type char3 = Struct_char3;
pub type uchar3 = Struct_uchar3;
pub type char4 = Struct_char4;
pub type uchar4 = Struct_uchar4;
pub type short1 = Struct_short1;
pub type ushort1 = Struct_ushort1;
pub type short2 = Struct_short2;
pub type ushort2 = Struct_ushort2;
pub type short3 = Struct_short3;
pub type ushort3 = Struct_ushort3;
pub type short4 = Struct_short4;
pub type ushort4 = Struct_ushort4;
pub type int1 = Struct_int1;
pub type uint1 = Struct_uint1;
pub type int2 = Struct_int2;
pub type uint2 = Struct_uint2;
pub type int3 = Struct_int3;
pub type uint3 = Struct_uint3;
pub type int4 = Struct_int4;
pub type uint4 = Struct_uint4;
pub type long1 = Struct_long1;
pub type ulong1 = Struct_ulong1;
pub type long2 = Struct_long2;
pub type ulong2 = Struct_ulong2;
pub type long3 = Struct_long3;
pub type ulong3 = Struct_ulong3;
pub type long4 = Struct_long4;
pub type ulong4 = Struct_ulong4;
pub type float1 = Struct_float1;
pub type float2 = Struct_float2;
pub type float3 = Struct_float3;
pub type float4 = Struct_float4;
pub type longlong1 = Struct_longlong1;
pub type ulonglong1 = Struct_ulonglong1;
pub type longlong2 = Struct_longlong2;
pub type ulonglong2 = Struct_ulonglong2;
pub type longlong3 = Struct_longlong3;
pub type ulonglong3 = Struct_ulonglong3;
pub type longlong4 = Struct_longlong4;
pub type ulonglong4 = Struct_ulonglong4;
pub type double1 = Struct_double1;
pub type double2 = Struct_double2;
pub type double3 = Struct_double3;
pub type double4 = Struct_double4;

#[repr(C)]
#[derive(Copy)]
pub struct Struct_dim3 {
    pub x: ::libc::c_uint,
    pub y: ::libc::c_uint,
    pub z: ::libc::c_uint,
}

impl ::std::clone::Clone for Struct_dim3 {
    fn clone(&self) -> Self { *self }
}

impl ::std::default::Default for Struct_dim3 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

pub type dim3 = Struct_dim3;

pub type cudaStreamCallback_t =
    ::std::option::Option<unsafe extern "C"
        fn(stream: cudaStream_t, status: cudaError_t, userData: *mut ::libc::c_void) -> ()
    >;

pub enum Struct_cudnnContext { }
pub type cudnnHandle_t = *mut Struct_cudnnContext;

pub enum cudnnStatus_t {
    CUDNN_STATUS_SUCCESS = 0,
    CUDNN_STATUS_NOT_INITIALIZED = 1,
    CUDNN_STATUS_ALLOC_FAILED = 2,
    CUDNN_STATUS_BAD_PARAM = 3,
    CUDNN_STATUS_INTERNAL_ERROR = 4,
    CUDNN_STATUS_INVALID_VALUE = 5,
    CUDNN_STATUS_ARCH_MISMATCH = 6,
    CUDNN_STATUS_MAPPING_ERROR = 7,
    CUDNN_STATUS_EXECUTION_FAILED = 8,
    CUDNN_STATUS_NOT_SUPPORTED = 9,
    CUDNN_STATUS_LICENSE_ERROR = 10,
}

pub enum Struct_cudnnTensorStruct { }
pub type cudnnTensorDescriptor_t = *mut Struct_cudnnTensorStruct;

pub enum Struct_cudnnConvolutionStruct { }
pub type cudnnConvolutionDescriptor_t = *mut Struct_cudnnConvolutionStruct;

pub enum Struct_cudnnPoolingStruct { }
pub type cudnnPoolingDescriptor_t = *mut Struct_cudnnPoolingStruct;

pub enum Struct_cudnnFilterStruct { }
pub type cudnnFilterDescriptor_t = *mut Struct_cudnnFilterStruct;

pub enum Struct_cudnnLRNStruct { }
pub type cudnnLRNDescriptor_t = *mut Struct_cudnnLRNStruct;

pub enum cudnnDataType_t {
    CUDNN_DATA_FLOAT = 0,
    CUDNN_DATA_DOUBLE = 1,
    CUDNN_DATA_HALF = 2,
}

pub enum cudnnTensorFormat_t {
    CUDNN_TENSOR_NCHW = 0,
    CUDNN_TENSOR_NHWC = 1,
}

pub enum cudnnAddMode_t {
    CUDNN_ADD_IMAGE = 0,
    CUDNN_ADD_SAME_HW = 0,
    CUDNN_ADD_FEATURE_MAP = 1,
    CUDNN_ADD_SAME_CHW = 1,
    CUDNN_ADD_SAME_C = 2,
    CUDNN_ADD_FULL_TENSOR = 3,
}

pub enum cudnnConvolutionMode_t {
    CUDNN_CONVOLUTION = 0,
    CUDNN_CROSS_CORRELATION = 1,
}

pub enum cudnnConvolutionFwdPreference_t {
    CUDNN_CONVOLUTION_FWD_NO_WORKSPACE = 0,
    CUDNN_CONVOLUTION_FWD_PREFER_FASTEST = 1,
    CUDNN_CONVOLUTION_FWD_SPECIFY_WORKSPACE_LIMIT = 2,
}

pub enum cudnnConvolutionFwdAlgo_t {
    CUDNN_CONVOLUTION_FWD_ALGO_IMPLICIT_GEMM = 0,
    CUDNN_CONVOLUTION_FWD_ALGO_IMPLICIT_PRECOMP_GEMM = 1,
    CUDNN_CONVOLUTION_FWD_ALGO_GEMM = 2,
    CUDNN_CONVOLUTION_FWD_ALGO_DIRECT = 3,
    CUDNN_CONVOLUTION_FWD_ALGO_FFT = 4,
}

#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed14 {
    pub algo: cudnnConvolutionFwdAlgo_t,
    pub status: cudnnStatus_t,
    pub time: ::libc::c_float,
    pub memory: size_t,
}
impl ::std::clone::Clone for Struct_Unnamed14 {
    fn clone(&self) -> Self { *self }
}
impl ::std::default::Default for Struct_Unnamed14 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type cudnnConvolutionFwdAlgoPerf_t = Struct_Unnamed14;

pub enum cudnnConvolutionBwdFilterPreference_t {
    CUDNN_CONVOLUTION_BWD_FILTER_NO_WORKSPACE = 0,
    CUDNN_CONVOLUTION_BWD_FILTER_PREFER_FASTEST = 1,
    CUDNN_CONVOLUTION_BWD_FILTER_SPECIFY_WORKSPACE_LIMIT = 2,
}

pub enum cudnnConvolutionBwdFilterAlgo_t {
    CUDNN_CONVOLUTION_BWD_FILTER_ALGO_0 = 0,
    CUDNN_CONVOLUTION_BWD_FILTER_ALGO_1 = 1,
    CUDNN_CONVOLUTION_BWD_FILTER_ALGO_FFT = 2,
    CUDNN_CONVOLUTION_BWD_FILTER_ALGO_3 = 3,
}

#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed17 {
    pub algo: cudnnConvolutionBwdFilterAlgo_t,
    pub status: cudnnStatus_t,
    pub time: ::libc::c_float,
    pub memory: size_t,
}

impl ::std::clone::Clone for Struct_Unnamed17 {
    fn clone(&self) -> Self { *self }
}

impl ::std::default::Default for Struct_Unnamed17 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

pub type cudnnConvolutionBwdFilterAlgoPerf_t = Struct_Unnamed17;

pub enum cudnnConvolutionBwdDataPreference_t {
    CUDNN_CONVOLUTION_BWD_DATA_NO_WORKSPACE = 0,
    CUDNN_CONVOLUTION_BWD_DATA_PREFER_FASTEST = 1,
    CUDNN_CONVOLUTION_BWD_DATA_SPECIFY_WORKSPACE_LIMIT = 2,
}

pub enum cudnnConvolutionBwdDataAlgo_t {
    CUDNN_CONVOLUTION_BWD_DATA_ALGO_0 = 0,
    CUDNN_CONVOLUTION_BWD_DATA_ALGO_1 = 1,
    CUDNN_CONVOLUTION_BWD_DATA_ALGO_FFT = 2,
}

#[repr(C)]
#[derive(Copy)]
pub struct Struct_Unnamed20 {
    pub algo: cudnnConvolutionBwdDataAlgo_t,
    pub status: cudnnStatus_t,
    pub time: ::libc::c_float,
    pub memory: size_t,
}

impl ::std::clone::Clone for Struct_Unnamed20 {
    fn clone(&self) -> Self { *self }
}

impl ::std::default::Default for Struct_Unnamed20 {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

pub type cudnnConvolutionBwdDataAlgoPerf_t = Struct_Unnamed20;

pub enum cudnnSoftmaxAlgorithm_t {
    CUDNN_SOFTMAX_FAST = 0,
    CUDNN_SOFTMAX_ACCURATE = 1,
    CUDNN_SOFTMAX_LOG = 2,
}

pub enum cudnnSoftmaxMode_t {
    CUDNN_SOFTMAX_MODE_INSTANCE = 0,
    CUDNN_SOFTMAX_MODE_CHANNEL = 1,
}

pub enum cudnnPoolingMode_t {
    CUDNN_POOLING_MAX = 0,
    CUDNN_POOLING_AVERAGE_COUNT_INCLUDE_PADDING = 1,
    CUDNN_POOLING_AVERAGE_COUNT_EXCLUDE_PADDING = 2,
}

pub enum cudnnActivationMode_t {
    CUDNN_ACTIVATION_SIGMOID = 0,
    CUDNN_ACTIVATION_RELU = 1,
    CUDNN_ACTIVATION_TANH = 2,
}

pub enum cudnnLRNMode_t {
    CUDNN_LRN_CROSS_CHANNEL_DIM1 = 0,
}

pub enum cudnnDivNormMode_t {
    CUDNN_DIVNORM_PRECOMPUTED_MEANS = 0,
}

#[link(name = "cudnn")]
extern "C" {
    pub fn cudnnGetVersion() -> size_t;

    pub fn cudnnGetErrorString(status: cudnnStatus_t) -> *const ::libc::c_char;

    pub fn cudnnCreate(handle: *mut cudnnHandle_t) -> cudnnStatus_t;

    pub fn cudnnDestroy(handle: cudnnHandle_t) -> cudnnStatus_t;

    pub fn cudnnSetStream(handle: cudnnHandle_t, streamId: cudaStream_t) -> cudnnStatus_t;

    pub fn cudnnGetStream(handle: cudnnHandle_t, streamId: *mut cudaStream_t) -> cudnnStatus_t;

    pub fn cudnnCreateTensorDescriptor(tensorDesc: *mut cudnnTensorDescriptor_t) -> cudnnStatus_t;

    pub fn cudnnSetTensor4dDescriptor(
        tensorDesc: cudnnTensorDescriptor_t,
        format: cudnnTensorFormat_t,
        dataType: cudnnDataType_t,
        n: ::libc::c_int, c: ::libc::c_int,
        h: ::libc::c_int, w: ::libc::c_int
    ) -> cudnnStatus_t;

    pub fn cudnnSetTensor4dDescriptorEx(
        tensorDesc: cudnnTensorDescriptor_t,
        dataType: cudnnDataType_t,
        n: ::libc::c_int, c: ::libc::c_int,
        h: ::libc::c_int, w: ::libc::c_int,
        nStride: ::libc::c_int,
        cStride: ::libc::c_int,
        hStride: ::libc::c_int,
        wStride: ::libc::c_int
    ) -> cudnnStatus_t;

    pub fn cudnnGetTensor4dDescriptor(
        tensorDesc: cudnnTensorDescriptor_t,
        dataType: *mut cudnnDataType_t,
        n: *mut ::libc::c_int,
        c: *mut ::libc::c_int,
        h: *mut ::libc::c_int,
        w: *mut ::libc::c_int,
        nStride: *mut ::libc::c_int,
        cStride: *mut ::libc::c_int,
        hStride: *mut ::libc::c_int,
        wStride: *mut ::libc::c_int
    ) -> cudnnStatus_t;

    pub fn cudnnSetTensorNdDescriptor(
        tensorDesc: cudnnTensorDescriptor_t,
        dataType: cudnnDataType_t,
        nbDims: ::libc::c_int,
        dimA: *const ::libc::c_int,
        strideA: *const ::libc::c_int
    ) -> cudnnStatus_t;

    pub fn cudnnGetTensorNdDescriptor(
        tensorDesc: cudnnTensorDescriptor_t,
        nbDimsRequested: ::libc::c_int,
        dataType: *mut cudnnDataType_t,
        nbDims: *mut ::libc::c_int,
        dimA: *mut ::libc::c_int,
        strideA: *mut ::libc::c_int
    ) -> cudnnStatus_t;

    pub fn cudnnDestroyTensorDescriptor(tensorDesc: cudnnTensorDescriptor_t) -> cudnnStatus_t;

    pub fn cudnnTransformTensor(
        handle: cudnnHandle_t,
        alpha: *const ::libc::c_void,
        srcDesc: cudnnTensorDescriptor_t,
        srcData: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        destDesc: cudnnTensorDescriptor_t,
        destData: *mut ::libc::c_void
    ) -> cudnnStatus_t;

    pub fn cudnnAddTensor(
        handle: cudnnHandle_t, mode: cudnnAddMode_t,
        alpha: *const ::libc::c_void,
        biasDesc: cudnnTensorDescriptor_t,
        biasData: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        srcDestDesc: cudnnTensorDescriptor_t,
        srcDestData: *mut ::libc::c_void
    ) -> cudnnStatus_t;

    pub fn cudnnAddTensor_v3(
        handle: cudnnHandle_t,
        alpha: *const ::libc::c_void,
        biasDesc: cudnnTensorDescriptor_t,
        biasData: *const ::libc::c_void,
        beta: *const ::libc::c_void,
        srcDestDesc: cudnnTensorDescriptor_t,
        srcDestData: *mut ::libc::c_void
    ) -> cudnnStatus_t;

    pub fn cudnnSetTensor(
        handle: cudnnHandle_t,
        srcDestDesc: cudnnTensorDescriptor_t,
        srcDestData: *mut ::libc::c_void,
        value: *const ::libc::c_void
    ) -> cudnnStatus_t;

    pub fn cudnnScaleTensor(
        handle: cudnnHandle_t,
        srcDestDesc: cudnnTensorDescriptor_t,
        srcDestData: *mut ::libc::c_void,
        alpha: *const ::libc::c_void
    ) -> cudnnStatus_t;

    pub fn cudnnCreateFilterDescriptor(filterDesc: *mut cudnnFilterDescriptor_t) -> cudnnStatus_t;

    pub fn cudnnSetFilter4dDescriptor(
        filterDesc: cudnnFilterDescriptor_t,
        dataType: cudnnDataType_t,
        k: ::libc::c_int, c: ::libc::c_int,
        h: ::libc::c_int, w: ::libc::c_int
    ) -> cudnnStatus_t;

    pub fn cudnnGetFilter4dDescriptor(
        filterDesc: cudnnFilterDescriptor_t,
        dataType: *mut cudnnDataType_t,
        k: *mut ::libc::c_int,
        c: *mut ::libc::c_int,
        h: *mut ::libc::c_int,
        w: *mut ::libc::c_int
    ) -> cudnnStatus_t;

    pub fn cudnnSetFilterNdDescriptor(
        filterDesc: cudnnFilterDescriptor_t,
        dataType: cudnnDataType_t,
        nbDims: ::libc::c_int,
        filterDimA: *const ::libc::c_int
    ) -> cudnnStatus_t;

    pub fn cudnnGetFilterNdDescriptor(
        filterDesc: cudnnFilterDescriptor_t,
        nbDimsRequested: ::libc::c_int,
        dataType: *mut cudnnDataType_t,
        nbDims: *mut ::libc::c_int,
        filterDimA: *mut ::libc::c_int
    ) -> cudnnStatus_t;

    pub fn cudnnDestroyFilterDescriptor(filterDesc: cudnnFilterDescriptor_t) -> cudnnStatus_t;

    pub fn cudnnCreateConvolutionDescriptor(convDesc: *mut cudnnConvolutionDescriptor_t) -> cudnnStatus_t;

    pub fn cudnnSetConvolution2dDescriptor(
        convDesc: cudnnConvolutionDescriptor_t,
        pad_h: ::libc::c_int,
        pad_w: ::libc::c_int,
        u: ::libc::c_int, v: ::libc::c_int,
        upscalex: ::libc::c_int,
        upscaley: ::libc::c_int,
        mode: cudnnConvolutionMode_t
    ) -> cudnnStatus_t;

    pub fn cudnnGetConvolution2dDescriptor(convDesc:
                                               cudnnConvolutionDescriptor_t,
                                           pad_h: *mut ::libc::c_int,
                                           pad_w: *mut ::libc::c_int,
                                           u: *mut ::libc::c_int,
                                           v: *mut ::libc::c_int,
                                           upscalex: *mut ::libc::c_int,
                                           upscaley: *mut ::libc::c_int,
                                           mode: *mut cudnnConvolutionMode_t)
     -> cudnnStatus_t;
    pub fn cudnnGetConvolution2dForwardOutputDim(convDesc:
                                                     cudnnConvolutionDescriptor_t,
                                                 inputTensorDesc:
                                                     cudnnTensorDescriptor_t,
                                                 filterDesc:
                                                     cudnnFilterDescriptor_t,
                                                 n: *mut ::libc::c_int,
                                                 c: *mut ::libc::c_int,
                                                 h: *mut ::libc::c_int,
                                                 w: *mut ::libc::c_int)
     -> cudnnStatus_t;
    pub fn cudnnSetConvolutionNdDescriptor(convDesc:
                                               cudnnConvolutionDescriptor_t,
                                           arrayLength: ::libc::c_int,
                                           padA: *const ::libc::c_int,
                                           filterStrideA:
                                               *const ::libc::c_int,
                                           upscaleA: *const ::libc::c_int,
                                           mode: cudnnConvolutionMode_t)
     -> cudnnStatus_t;
    pub fn cudnnGetConvolutionNdDescriptor(convDesc:
                                               cudnnConvolutionDescriptor_t,
                                           arrayLengthRequested:
                                               ::libc::c_int,
                                           arrayLength: *mut ::libc::c_int,
                                           padA: *mut ::libc::c_int,
                                           strideA: *mut ::libc::c_int,
                                           upscaleA: *mut ::libc::c_int,
                                           mode: *mut cudnnConvolutionMode_t)
     -> cudnnStatus_t;
    pub fn cudnnSetConvolutionNdDescriptor_v3(convDesc:
                                                  cudnnConvolutionDescriptor_t,
                                              arrayLength: ::libc::c_int,
                                              padA: *const ::libc::c_int,
                                              filterStrideA:
                                                  *const ::libc::c_int,
                                              upscaleA: *const ::libc::c_int,
                                              mode: cudnnConvolutionMode_t,
                                              dataType: cudnnDataType_t)
     -> cudnnStatus_t;
    pub fn cudnnGetConvolutionNdDescriptor_v3(convDesc:
                                                  cudnnConvolutionDescriptor_t,
                                              arrayLengthRequested:
                                                  ::libc::c_int,
                                              arrayLength: *mut ::libc::c_int,
                                              padA: *mut ::libc::c_int,
                                              strideA: *mut ::libc::c_int,
                                              upscaleA: *mut ::libc::c_int,
                                              mode:
                                                  *mut cudnnConvolutionMode_t,
                                              dataType: *mut cudnnDataType_t)
     -> cudnnStatus_t;
    pub fn cudnnGetConvolutionNdForwardOutputDim(convDesc:
                                                     cudnnConvolutionDescriptor_t,
                                                 inputTensorDesc:
                                                     cudnnTensorDescriptor_t,
                                                 filterDesc:
                                                     cudnnFilterDescriptor_t,
                                                 nbDims: ::libc::c_int,
                                                 tensorOuputDimA:
                                                     *mut ::libc::c_int)
     -> cudnnStatus_t;
    pub fn cudnnDestroyConvolutionDescriptor(convDesc:
                                                 cudnnConvolutionDescriptor_t)
     -> cudnnStatus_t;
    pub fn cudnnFindConvolutionForwardAlgorithm(handle: cudnnHandle_t,
                                                srcDesc:
                                                    cudnnTensorDescriptor_t,
                                                filterDesc:
                                                    cudnnFilterDescriptor_t,
                                                convDesc:
                                                    cudnnConvolutionDescriptor_t,
                                                destDesc:
                                                    cudnnTensorDescriptor_t,
                                                requestedAlgoCount:
                                                    ::libc::c_int,
                                                returnedAlgoCount:
                                                    *mut ::libc::c_int,
                                                perfResults:
                                                    *mut cudnnConvolutionFwdAlgoPerf_t)
     -> cudnnStatus_t;
    pub fn cudnnGetConvolutionForwardAlgorithm(handle: cudnnHandle_t,
                                               srcDesc:
                                                   cudnnTensorDescriptor_t,
                                               filterDesc:
                                                   cudnnFilterDescriptor_t,
                                               convDesc:
                                                   cudnnConvolutionDescriptor_t,
                                               destDesc:
                                                   cudnnTensorDescriptor_t,
                                               preference:
                                                   cudnnConvolutionFwdPreference_t,
                                               memoryLimitInbytes: size_t,
                                               algo:
                                                   *mut cudnnConvolutionFwdAlgo_t)
     -> cudnnStatus_t;
    pub fn cudnnGetConvolutionForwardWorkspaceSize(handle: cudnnHandle_t,
                                                   srcDesc:
                                                       cudnnTensorDescriptor_t,
                                                   filterDesc:
                                                       cudnnFilterDescriptor_t,
                                                   convDesc:
                                                       cudnnConvolutionDescriptor_t,
                                                   destDesc:
                                                       cudnnTensorDescriptor_t,
                                                   algo:
                                                       cudnnConvolutionFwdAlgo_t,
                                                   sizeInBytes: *mut size_t)
     -> cudnnStatus_t;
    pub fn cudnnConvolutionForward(handle: cudnnHandle_t,
                                   alpha: *const ::libc::c_void,
                                   srcDesc: cudnnTensorDescriptor_t,
                                   srcData: *const ::libc::c_void,
                                   filterDesc: cudnnFilterDescriptor_t,
                                   filterData: *const ::libc::c_void,
                                   convDesc: cudnnConvolutionDescriptor_t,
                                   algo: cudnnConvolutionFwdAlgo_t,
                                   workSpace: *mut ::libc::c_void,
                                   workSpaceSizeInBytes: size_t,
                                   beta: *const ::libc::c_void,
                                   destDesc: cudnnTensorDescriptor_t,
                                   destData: *mut ::libc::c_void)
     -> cudnnStatus_t;
    pub fn cudnnConvolutionBackwardBias(handle: cudnnHandle_t,
                                        alpha: *const ::libc::c_void,
                                        srcDesc: cudnnTensorDescriptor_t,
                                        srcData: *const ::libc::c_void,
                                        beta: *const ::libc::c_void,
                                        destDesc: cudnnTensorDescriptor_t,
                                        destData: *mut ::libc::c_void)
     -> cudnnStatus_t;
    pub fn cudnnFindConvolutionBackwardFilterAlgorithm(handle: cudnnHandle_t,
                                                       srcDesc:
                                                           cudnnTensorDescriptor_t,
                                                       diffDesc:
                                                           cudnnTensorDescriptor_t,
                                                       convDesc:
                                                           cudnnConvolutionDescriptor_t,
                                                       gradDesc:
                                                           cudnnFilterDescriptor_t,
                                                       requestedAlgoCount:
                                                           ::libc::c_int,
                                                       returnedAlgoCount:
                                                           *mut ::libc::c_int,
                                                       perfResults:
                                                           *mut cudnnConvolutionBwdFilterAlgoPerf_t)
     -> cudnnStatus_t;
    pub fn cudnnGetConvolutionBackwardFilterAlgorithm(handle: cudnnHandle_t,
                                                      srcDesc:
                                                          cudnnTensorDescriptor_t,
                                                      diffDesc:
                                                          cudnnTensorDescriptor_t,
                                                      convDesc:
                                                          cudnnConvolutionDescriptor_t,
                                                      gradDesc:
                                                          cudnnFilterDescriptor_t,
                                                      preference:
                                                          cudnnConvolutionBwdFilterPreference_t,
                                                      memoryLimitInbytes:
                                                          size_t,
                                                      algo:
                                                          *mut cudnnConvolutionBwdFilterAlgo_t)
     -> cudnnStatus_t;
    pub fn cudnnGetConvolutionBackwardFilterWorkspaceSize(handle:
                                                              cudnnHandle_t,
                                                          srcDesc:
                                                              cudnnTensorDescriptor_t,
                                                          diffDesc:
                                                              cudnnTensorDescriptor_t,
                                                          convDesc:
                                                              cudnnConvolutionDescriptor_t,
                                                          gradDesc:
                                                              cudnnFilterDescriptor_t,
                                                          algo:
                                                              cudnnConvolutionBwdFilterAlgo_t,
                                                          sizeInBytes:
                                                              *mut size_t)
     -> cudnnStatus_t;
    pub fn cudnnConvolutionBackwardFilter_v3(handle: cudnnHandle_t,
                                             alpha: *const ::libc::c_void,
                                             srcDesc: cudnnTensorDescriptor_t,
                                             srcData: *const ::libc::c_void,
                                             diffDesc:
                                                 cudnnTensorDescriptor_t,
                                             diffData: *const ::libc::c_void,
                                             convDesc:
                                                 cudnnConvolutionDescriptor_t,
                                             algo:
                                                 cudnnConvolutionBwdFilterAlgo_t,
                                             workSpace: *mut ::libc::c_void,
                                             workSpaceSizeInBytes: size_t,
                                             beta: *const ::libc::c_void,
                                             gradDesc:
                                                 cudnnFilterDescriptor_t,
                                             gradData: *mut ::libc::c_void)
     -> cudnnStatus_t;
    pub fn cudnnConvolutionBackwardFilter(handle: cudnnHandle_t,
                                          alpha: *const ::libc::c_void,
                                          srcDesc: cudnnTensorDescriptor_t,
                                          srcData: *const ::libc::c_void,
                                          diffDesc: cudnnTensorDescriptor_t,
                                          diffData: *const ::libc::c_void,
                                          convDesc:
                                              cudnnConvolutionDescriptor_t,
                                          beta: *const ::libc::c_void,
                                          gradDesc: cudnnFilterDescriptor_t,
                                          gradData: *mut ::libc::c_void)
     -> cudnnStatus_t;
    pub fn cudnnFindConvolutionBackwardDataAlgorithm(handle: cudnnHandle_t,
                                                     filterDesc:
                                                         cudnnFilterDescriptor_t,
                                                     diffDesc:
                                                         cudnnTensorDescriptor_t,
                                                     convDesc:
                                                         cudnnConvolutionDescriptor_t,
                                                     gradDesc:
                                                         cudnnTensorDescriptor_t,
                                                     requestedAlgoCount:
                                                         ::libc::c_int,
                                                     returnedAlgoCount:
                                                         *mut ::libc::c_int,
                                                     perfResults:
                                                         *mut cudnnConvolutionBwdDataAlgoPerf_t)
     -> cudnnStatus_t;
    pub fn cudnnGetConvolutionBackwardDataAlgorithm(handle: cudnnHandle_t,
                                                    filterDesc:
                                                        cudnnFilterDescriptor_t,
                                                    diffDesc:
                                                        cudnnTensorDescriptor_t,
                                                    convDesc:
                                                        cudnnConvolutionDescriptor_t,
                                                    gradDesc:
                                                        cudnnTensorDescriptor_t,
                                                    preference:
                                                        cudnnConvolutionBwdDataPreference_t,
                                                    memoryLimitInbytes:
                                                        size_t,
                                                    algo:
                                                        *mut cudnnConvolutionBwdDataAlgo_t)
     -> cudnnStatus_t;
    pub fn cudnnGetConvolutionBackwardDataWorkspaceSize(handle: cudnnHandle_t,
                                                        filterDesc:
                                                            cudnnFilterDescriptor_t,
                                                        diffDesc:
                                                            cudnnTensorDescriptor_t,
                                                        convDesc:
                                                            cudnnConvolutionDescriptor_t,
                                                        gradDesc:
                                                            cudnnTensorDescriptor_t,
                                                        algo:
                                                            cudnnConvolutionBwdDataAlgo_t,
                                                        sizeInBytes:
                                                            *mut size_t)
     -> cudnnStatus_t;
    pub fn cudnnConvolutionBackwardData_v3(handle: cudnnHandle_t,
                                           alpha: *const ::libc::c_void,
                                           filterDesc:
                                               cudnnFilterDescriptor_t,
                                           filterData: *const ::libc::c_void,
                                           diffDesc: cudnnTensorDescriptor_t,
                                           diffData: *const ::libc::c_void,
                                           convDesc:
                                               cudnnConvolutionDescriptor_t,
                                           algo:
                                               cudnnConvolutionBwdDataAlgo_t,
                                           workSpace: *mut ::libc::c_void,
                                           workSpaceSizeInBytes: size_t,
                                           beta: *const ::libc::c_void,
                                           gradDesc: cudnnTensorDescriptor_t,
                                           gradData: *mut ::libc::c_void)
     -> cudnnStatus_t;
    pub fn cudnnConvolutionBackwardData(handle: cudnnHandle_t,
                                        alpha: *const ::libc::c_void,
                                        filterDesc: cudnnFilterDescriptor_t,
                                        filterData: *const ::libc::c_void,
                                        diffDesc: cudnnTensorDescriptor_t,
                                        diffData: *const ::libc::c_void,
                                        convDesc:
                                            cudnnConvolutionDescriptor_t,
                                        beta: *const ::libc::c_void,
                                        gradDesc: cudnnTensorDescriptor_t,
                                        gradData: *mut ::libc::c_void)
     -> cudnnStatus_t;
    pub fn cudnnIm2Col(handle: cudnnHandle_t,
                       srcDesc: cudnnTensorDescriptor_t,
                       srcData: *const ::libc::c_void,
                       filterDesc: cudnnFilterDescriptor_t,
                       convDesc: cudnnConvolutionDescriptor_t,
                       colBuffer: *mut ::libc::c_void) -> cudnnStatus_t;
    pub fn cudnnSoftmaxForward(handle: cudnnHandle_t,
                               algorithm: cudnnSoftmaxAlgorithm_t,
                               mode: cudnnSoftmaxMode_t,
                               alpha: *const ::libc::c_void,
                               srcDesc: cudnnTensorDescriptor_t,
                               srcData: *const ::libc::c_void,
                               beta: *const ::libc::c_void,
                               destDesc: cudnnTensorDescriptor_t,
                               destData: *mut ::libc::c_void)
     -> cudnnStatus_t;
    pub fn cudnnSoftmaxBackward(handle: cudnnHandle_t,
                                algorithm: cudnnSoftmaxAlgorithm_t,
                                mode: cudnnSoftmaxMode_t,
                                alpha: *const ::libc::c_void,
                                srcDesc: cudnnTensorDescriptor_t,
                                srcData: *const ::libc::c_void,
                                srcDiffDesc: cudnnTensorDescriptor_t,
                                srcDiffData: *const ::libc::c_void,
                                beta: *const ::libc::c_void,
                                destDiffDesc: cudnnTensorDescriptor_t,
                                destDiffData: *mut ::libc::c_void)
     -> cudnnStatus_t;
    pub fn cudnnCreatePoolingDescriptor(poolingDesc:
                                            *mut cudnnPoolingDescriptor_t)
     -> cudnnStatus_t;
    pub fn cudnnSetPooling2dDescriptor(poolingDesc: cudnnPoolingDescriptor_t,
                                       mode: cudnnPoolingMode_t,
                                       windowHeight: ::libc::c_int,
                                       windowWidth: ::libc::c_int,
                                       verticalPadding: ::libc::c_int,
                                       horizontalPadding: ::libc::c_int,
                                       verticalStride: ::libc::c_int,
                                       horizontalStride: ::libc::c_int)
     -> cudnnStatus_t;
    pub fn cudnnGetPooling2dDescriptor(poolingDesc: cudnnPoolingDescriptor_t,
                                       mode: *mut cudnnPoolingMode_t,
                                       windowHeight: *mut ::libc::c_int,
                                       windowWidth: *mut ::libc::c_int,
                                       verticalPadding: *mut ::libc::c_int,
                                       horizontalPadding: *mut ::libc::c_int,
                                       verticalStride: *mut ::libc::c_int,
                                       horizontalStride: *mut ::libc::c_int)
     -> cudnnStatus_t;
    pub fn cudnnSetPoolingNdDescriptor(poolingDesc: cudnnPoolingDescriptor_t,
                                       mode: cudnnPoolingMode_t,
                                       nbDims: ::libc::c_int,
                                       windowDimA: *const ::libc::c_int,
                                       paddingA: *const ::libc::c_int,
                                       strideA: *const ::libc::c_int)
     -> cudnnStatus_t;
    pub fn cudnnGetPoolingNdDescriptor(poolingDesc: cudnnPoolingDescriptor_t,
                                       nbDimsRequested: ::libc::c_int,
                                       mode: *mut cudnnPoolingMode_t,
                                       nbDims: *mut ::libc::c_int,
                                       windowDimA: *mut ::libc::c_int,
                                       paddingA: *mut ::libc::c_int,
                                       strideA: *mut ::libc::c_int)
     -> cudnnStatus_t;
    pub fn cudnnGetPoolingNdForwardOutputDim(poolingDesc:
                                                 cudnnPoolingDescriptor_t,
                                             inputTensorDesc:
                                                 cudnnTensorDescriptor_t,
                                             nbDims: ::libc::c_int,
                                             outputTensorDimA:
                                                 *mut ::libc::c_int)
     -> cudnnStatus_t;
    pub fn cudnnGetPooling2dForwardOutputDim(poolingDesc:
                                                 cudnnPoolingDescriptor_t,
                                             inputTensorDesc:
                                                 cudnnTensorDescriptor_t,
                                             outN: *mut ::libc::c_int,
                                             outC: *mut ::libc::c_int,
                                             outH: *mut ::libc::c_int,
                                             outW: *mut ::libc::c_int)
     -> cudnnStatus_t;
    pub fn cudnnDestroyPoolingDescriptor(poolingDesc:
                                             cudnnPoolingDescriptor_t)
     -> cudnnStatus_t;
    pub fn cudnnPoolingForward(handle: cudnnHandle_t,
                               poolingDesc: cudnnPoolingDescriptor_t,
                               alpha: *const ::libc::c_void,
                               srcDesc: cudnnTensorDescriptor_t,
                               srcData: *const ::libc::c_void,
                               beta: *const ::libc::c_void,
                               destDesc: cudnnTensorDescriptor_t,
                               destData: *mut ::libc::c_void)
     -> cudnnStatus_t;
    pub fn cudnnPoolingBackward(handle: cudnnHandle_t,
                                poolingDesc: cudnnPoolingDescriptor_t,
                                alpha: *const ::libc::c_void,
                                srcDesc: cudnnTensorDescriptor_t,
                                srcData: *const ::libc::c_void,
                                srcDiffDesc: cudnnTensorDescriptor_t,
                                srcDiffData: *const ::libc::c_void,
                                destDesc: cudnnTensorDescriptor_t,
                                destData: *const ::libc::c_void,
                                beta: *const ::libc::c_void,
                                destDiffDesc: cudnnTensorDescriptor_t,
                                destDiffData: *mut ::libc::c_void)
     -> cudnnStatus_t;
    pub fn cudnnActivationForward(handle: cudnnHandle_t,
                                  mode: cudnnActivationMode_t,
                                  alpha: *const ::libc::c_void,
                                  srcDesc: cudnnTensorDescriptor_t,
                                  srcData: *const ::libc::c_void,
                                  beta: *const ::libc::c_void,
                                  destDesc: cudnnTensorDescriptor_t,
                                  destData: *mut ::libc::c_void)
     -> cudnnStatus_t;
    pub fn cudnnActivationBackward(handle: cudnnHandle_t,
                                   mode: cudnnActivationMode_t,
                                   alpha: *const ::libc::c_void,
                                   srcDesc: cudnnTensorDescriptor_t,
                                   srcData: *const ::libc::c_void,
                                   srcDiffDesc: cudnnTensorDescriptor_t,
                                   srcDiffData: *const ::libc::c_void,
                                   destDesc: cudnnTensorDescriptor_t,
                                   destData: *const ::libc::c_void,
                                   beta: *const ::libc::c_void,
                                   destDiffDesc: cudnnTensorDescriptor_t,
                                   destDiffData: *mut ::libc::c_void)
     -> cudnnStatus_t;
    pub fn cudnnCreateLRNDescriptor(normDesc: *mut cudnnLRNDescriptor_t)
     -> cudnnStatus_t;
    pub fn cudnnSetLRNDescriptor(normDesc: cudnnLRNDescriptor_t,
                                 lrnN: ::libc::c_uint,
                                 lrnAlpha: ::libc::c_double,
                                 lrnBeta: ::libc::c_double,
                                 lrnK: ::libc::c_double) -> cudnnStatus_t;
    pub fn cudnnGetLRNDescriptor(normDesc: cudnnLRNDescriptor_t,
                                 lrnN: *mut ::libc::c_uint,
                                 lrnAlpha: *mut ::libc::c_double,
                                 lrnBeta: *mut ::libc::c_double,
                                 lrnK: *mut ::libc::c_double)
     -> cudnnStatus_t;
    pub fn cudnnDestroyLRNDescriptor(lrnDesc: cudnnLRNDescriptor_t)
     -> cudnnStatus_t;
    pub fn cudnnLRNCrossChannelForward(handle: cudnnHandle_t,
                                       normDesc: cudnnLRNDescriptor_t,
                                       lrnMode: cudnnLRNMode_t,
                                       alpha: *const ::libc::c_void,
                                       srcDesc: cudnnTensorDescriptor_t,
                                       srcData: *const ::libc::c_void,
                                       beta: *const ::libc::c_void,
                                       destDesc: cudnnTensorDescriptor_t,
                                       destData: *mut ::libc::c_void)
     -> cudnnStatus_t;
    pub fn cudnnLRNCrossChannelBackward(handle: cudnnHandle_t,
                                        normDesc: cudnnLRNDescriptor_t,
                                        lrnMode: cudnnLRNMode_t,
                                        alpha: *const ::libc::c_void,
                                        srcDesc: cudnnTensorDescriptor_t,
                                        srcData: *const ::libc::c_void,
                                        srcDiffDesc: cudnnTensorDescriptor_t,
                                        srcDiffData: *const ::libc::c_void,
                                        destDesc: cudnnTensorDescriptor_t,
                                        destData: *const ::libc::c_void,
                                        beta: *const ::libc::c_void,
                                        destDiffDesc: cudnnTensorDescriptor_t,
                                        destDiffData: *mut ::libc::c_void)
     -> cudnnStatus_t;
    pub fn cudnnDivisiveNormalizationForward(handle: cudnnHandle_t,
                                             normDesc: cudnnLRNDescriptor_t,
                                             mode: cudnnDivNormMode_t,
                                             alpha: *const ::libc::c_void,
                                             srcDesc: cudnnTensorDescriptor_t,
                                             srcData: *const ::libc::c_void,
                                             srcMeansData:
                                                 *const ::libc::c_void,
                                             tempData: *mut ::libc::c_void,
                                             tempData2: *mut ::libc::c_void,
                                             beta: *const ::libc::c_void,
                                             destDesc:
                                                 cudnnTensorDescriptor_t,
                                             destData: *mut ::libc::c_void)
     -> cudnnStatus_t;
    pub fn cudnnDivisiveNormalizationBackward(handle: cudnnHandle_t,
                                              normDesc: cudnnLRNDescriptor_t,
                                              mode: cudnnDivNormMode_t,
                                              alpha: *const ::libc::c_void,
                                              srcDesc:
                                                  cudnnTensorDescriptor_t,
                                              srcData: *const ::libc::c_void,
                                              srcMeansData:
                                                  *const ::libc::c_void,
                                              srcDiffData:
                                                  *const ::libc::c_void,
                                              tempData: *mut ::libc::c_void,
                                              tempData2: *mut ::libc::c_void,
                                              betaData: *const ::libc::c_void,
                                              destDataDesc:
                                                  cudnnTensorDescriptor_t,
                                              destDataDiff:
                                                  *mut ::libc::c_void,
                                              destMeansDiff:
                                                  *mut ::libc::c_void)
     -> cudnnStatus_t;
}
